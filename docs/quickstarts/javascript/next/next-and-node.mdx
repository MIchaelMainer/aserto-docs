---
sidebar_label: NextJS, Auth0, Netlify and Aserto
---

# NextJS, Auth0, Netlify and Aserto

In this tutorial, we'll learn how to create a Next.JS application that uses Aserto to authorize users that were authenticated with Auth0. We'll learn how to set up protected paths and how to use Aserto's SDK to perform conditional UI rendering.

## Table of Contents

1. Set up a NextJS application
2. Connect with Auth0
3. Set up Aserto Function on netlify
4. Create an Aserto policy
5. Create protected paths

## Prerequisites

1. Aserto account
2. Auth0 account
3. Your favorite IDE

## Auth0 Setup

Follow the steps in [this tutorial](/docs/getting-started/set-up-users) to set up your Auth0 account and to seed it with mock users.

## Application Setup

To start a new application with Next.js, we’ll use the `create-next-app` CLI tool. Start by executing:

```
npx create-next-app@latest nextjs-aserto-demo -e https://github.com/aserto-demo/aserto-nextjs
```

Next, we’ll `cd` into the newly created folder and start the development server:

```
cd nextjs-aserto-demo
yarn dev
```

## Add Auth0 to the application

To add authentication with Auth0 to your app, install the dependency:

```
yarn add @auth0/nextjs-auth0
```

Then, in the `api` folder, create a folder called `auth`. In it, create a file with the name `[...auth0].js` and add the following to it:

```
import { handleAuth } from '@auth0/nextjs-auth0';

export default handleAuth();

```

This will allow us to use the utilities and hooks Auth0 provides across our application.

## Configure Auth0

First, we'll have to generate a secret using `openssl`:

```
openssl rand -hex 32
```

This will generate a random string that we'll use momentarily.

Next, create a file called `.env` in the root folder, and insert the required values using the random string you created as well the Auth0 credentials for the SPA and API you created there.

```
AUTH0_SECRET={your-own-secret-generated-with-openssl}
AUTH0_BASE_URL=http://localhost:3000
AUTH0_ISSUER_BASE_URL='https://{AUTH0_DOMAIN}'
AUTH0_CLIENT_ID='{AUTH0_CLIENT_ID}'
AUTH0_CLIENT_SECRET='{AUTH0_CLIENT_SECRET}'
AUTH0_AUDIENCE={AUTH0_API_IDENTIFIER}
AUTH0_SCOPE='openid profile'
```

## Update the application to use Auth0 Authentication

Under `pages`, open the file `_app.js`. This is the entry point for the application. Add the following Auth0 dependency :

```js
import { UserProvider } from "@auth0/nextjs-auth0";
```

Wrap the `<Layout>` component with the `<UserProvider>`:

```js
...
<UserProvider>
    <Layout>
        <Component {...pageProps} />
    </Layout>
</UserProvider>
...
```

Next, we'll update the navigation bar and add the user information to it, as well as a login/logout button. Under `components`, open `NavBar.jsx` and add the following dependencies:

```js
import { useUser } from "@auth0/nextjs-auth0";
import AnchorLink from "./AnchorLink";
import Image from "next/image";
import styles from "../styles/NavBar.module.css";
```

Then add the following portions to the NavBar component:

```js
<Navbar color="light" expand="md" light>
  ...
  <Collapse navbar>
    ...
    {!isLoading && !user && (
      <Nav>
        <NavItem id="qsLoginBtn">
          <AnchorLink
            href="/api/auth/login"
            className="btn btn-primary btn-margin"
            tabIndex={0}
            testId="navbar-login-desktop"
          >
            Log in
          </AnchorLink>
        </NavItem>
      </Nav>
    )}
    {user && (
      <Nav>
        <NavItem className={styles.userimage}>
          <Image
            src={user.picture}
            alt="Profile"
            className="nav-user-profile d-inline-block rounded-circle mr-3"
            width="50"
            height="50"
            decode="async"
            data-testid="navbar-picture-mobile"
          />
        </NavItem>
        <NavItem className={styles.username}>
          <span className="d-inline-block" data-testid="navbar-user-mobile">
            {user.name}
          </span>
        </NavItem>
        <NavItem id="qsLogoutBtn">
          <AnchorLink
            href="/api/auth/logout"
            className="btn btn-secondary btn-margin"
            testId="navbar-logout-mobile"
          >
            Log out
          </AnchorLink>
        </NavItem>
      </Nav>
    )}
  </Collapse>
</Navbar>
```

## Create a Protected Pages

We can now leverage the authentication layer of our app to create protected pages. Let's start by modifying `protectedPage.jsx` to use `withPageAuthRequired`:

```js
import React from "react";
import { withPageAuthRequired } from "@auth0/nextjs-auth0";
import styles from "../styles/ProtectedPage.module.css";

export default withPageAuthRequired(function ProtectedPage() {
  return <div className={styles.main}>Protected Page</div>;
});
```

## Test the application

Log in to the application using the following credentials:

User name: `euang@acmecorp.com`
Password: `V@rySecr#et321!`

Navigate to the "Protected Page" - you should see the following:

![protected-page](/quickstart-next-and-node/protected-page-bare.png)

When you log out and try to navigate to the protected page, we'll be redirected to a log in screen.

## Checkpoint

So far, we've created a simple Next.js application with a protected route. Next, we're going to add an authorization layer leveraging Aserto's Express.js SDK.

# Authorization

## The Aserto Policy

The core of the authorization process is the policy: a set of rules that define who has access to any particular resource defined by the policy. The policy is comprised of policy files written in Rego and optionally a data file (usually named `data.json`) which the policy files refer to. At runtime, the authorizer uses the policy and user information found in the Edge Directory Service to make authorization decisions.

Below is an example of a user object:

```js
{
  "id": "0b23837b-8fdb-4edf-a50b-325ed0625086",
  "enabled": true,
  "display_name": "Jeff Hay",
  "email": "jeffh@acmecorp.com",
  "picture": "https://github.com/aserto-demo/contoso-ad-sample/raw/main/UserImages/Jeff%20Hay.jpg",
  "identities": {
    ...
  },
  "attributes": {
    "properties": {
      "department": "Executive",
      "manager": "8724dd1b-c401-4487-9ea8-4c224ef67710",
      "phone": "+1-425-555-0187",
      "title": "CVP of Operations"
    },
    "roles": [
      "acmecorp",
      "executive",
      "user"
    ],
    "permissions": []
  },
  ...
  "metadata": {
    "created_at": "2021-07-09T01:36:14.086Z",
    "updated_at": "2021-11-22T20:15:22.361090510Z",
    "deleted_at": null
  },
  "deleted": false
}
```

Note the `attributes` section which we'll refer to in our policy.

## Add a policy

In [console.aserto.com](console.aserto.com), go to the Policy tab and click "Add Policy":

![add-policy](/quickstart-next-and-node/add-policy.png)

If you haven't already added a source code connection, select "Add a new source code connection". You can choose either adding a Github connection using an Oauth2 flow, or add a Github connection using a Github PAT.

![add-connection](/quickstart-next-and-node/add-scc.png)

Once you've added the connection, select the organization you'd like to use for the repository, and select "New (using template)".

Then, from the template dropdown, select "aserto-dev/policy-template". Name repo policy "hello-aserto-nextjs", and click "Create repo".

![create-repo](/quickstart-next-and-node/add-github.png)

Finally, name the policy "hello-aserto-nextjs", and click "Add policy".

## Modify the policy

Head to Github to retrieve the URL for the repository that was just created, and clone it.

```
git clone git@github.com:<YOUR ORGANIZATION>/hello-aserto-nextjs.git
```

Now that we have a local copy of the policy, let’s start modifying it:

We'll start by updating the `.manifest` file under `src`, which currently will only point to the root of our policy. We'll change it from

```
{
    "roots": ["policies"]
}
```

To

```
{
    "roots": ["asertonextjs"]
}
```

### Create a `data.json` file

As mentioned before, our policy can use a data file to specify roles and decisions relating to those roles. Create a file called `data.json` in the `src` folder and copy the following content:

```
{
  "roles": {
    "project-management": {
      "perms": {
        "asertonextjs.GET.api.protected": {
          "allowed": false
        }
      }
    },
    "executive": {
      "perms": {
        "asertonextjs.GET.api.protected": {
          "allowed": true,
        }
      }
    }
  }
}
```

In this file, we've defined two roles: `project-management` which will not be allowed access to the resource, and `executive` which will have access. Next we'll see how to define our policies to make use of these definitions.

Rename the file `hello.rego` to `protected.rego`. We'll open the file and change the package name to match the path of our Express API endpoint. The basic structure of the package name is:

```
[policy-root].[VERB].[path]
```

Where the path is separated by dots instead of slashes. And so in our case, the Express.js path

```
app.get('/api/protected'...
```

Is referenced in the package as:

```
package asertonextjs.GET.api.protected
```

Aserto makes several variables available to the policies at runtime - in this example we'll use `input.policy` and `input.user`:

```
import input.policy.path
import input.user.attributes.roles as user_roles
```

These two `import` statements allow us to refer to the `path` property and the `user_roles` alias without having to reference the full path in the policy. The `input.policy` reference points to the policy itself, and the `path` property in this case would be `asertonextjs.GET.api.protected`. The path aliased by `user_roles` refers to the `input.user.attributes.roles` path within user object mentioned above.

Next, we're going to define the default value for the `allowed` decision for this resource (`asertonextjs.GET.api.protected`):

```
default allowed = false

```

By default, it will be `false` - this follows the principle of a “closed” system where access is disallowed unless specific conditions are satisfied.

```
allowed {
	some index
	data.roles[user_roles[index]].perms[path].allowed
}
```

On runtime, the application will send the JWT associated with the logged in user. The Express.js service will relay the JWT along with the request path as the identity and resource contexts respectively to the authorizer. The `some index` and `...roles[index]` expressions indicate the authorizer will iterate over all the elements in the `roles` array under the `attributes` property in the user object. The authorizer will check if the iterated role is equal to the string `executive`. If it is, the `allowed` decision will be `true`.

Here is the finished policy file:

```
import input.policy.path
import input.user.attributes.roles as user_roles

default allowed = false

allowed {
	some index
	data.roles[user_roles[index]].perms[path].allowed
}
```

### Updating the Policy Repository

Now that we’ve modified our policy bundle, we’ll publish our changes: Aserto takes a “policy-as-code” approach to handling policies. That means that we can simply tag and push the changes we’ve made to the policy and the updated policy will be built and published to the authorizer. This allows us to make changes to the policy without having to make changes or redeploy our application.
Commit, tag and push the changes you made:

```
git commit -m "updated policy"
git tag v0.0.1
git push origin master
git push --tags
```

## Create an Express.js service

The component which makes decisions in runtime is called the _Aserto Authorizer_. It is an open source authorization engine which uses Open Policy Agent (OPA) to compute a decision based on policy, user context and resource data. In this tutorial we’re going to use the hosted version of this authorizer, but note that it could be deployed as a sidecar together with your application.

To communicate with the Aserto Authorizer, we'll need to set up an Express.js service that will make use of the Aserto Javascript middleware package.

To start, create a folder called `service` and in it create a file called `api-server.js`.

Next, add the dependencies:

```js
require("dotenv").config({ path: "./.env" });

const express = require("express");
const cors = require("cors");
const morgan = require("morgan");
const helmet = require("helmet");
const jwt = require("express-jwt");
const jwksRsa = require("jwks-rsa");
const { displayStateMap, jwtAuthz } = require("express-jwt-aserto");
const bodyParser = require("body-parser");
```

Then, initialize the Express app and router:

```js
const app = express();
const router = express.Router();
```

Next, reference the environment variables:

```js
const port = process.env.API_PORT || 3001;
const baseUrl = process.env.AUTH0_BASE_URL;
const issuerBaseUrl = process.env.AUTH0_ISSUER_BASE_URL;
const audience = process.env.AUTH0_AUDIENCE;
const isNetlify = process.env.NETLIFY;
```

Configure the router base path:

```js
const routerBasePath = "/";
```

Initialize the `checkJWT` middleware:

```js
const checkJwt = jwt({
  secret: jwksRsa.expressJwtSecret({
    cache: true,
    rateLimit: true,
    jwksRequestsPerMinute: 5,
    jwksUri: `${issuerBaseUrl}/.well-known/jwks.json`,
  }),
  audience: audience,
  issuer: `${issuerBaseUrl}/`,
  algorithms: ["RS256"],
});
```

Configure and initialize the Aserto Authorization middleware:

```js
//Aserto authorizer configuration
const authzOptions = {
  authorizerServiceUrl: process.env.AUTHORIZER_SERVICE_URL,
  policyId: process.env.POLICY_ID,
  policyRoot: process.env.POLICY_ROOT,
  authorizerApiKey: process.env.AUTHORIZER_API_KEY,
  tenantId: process.env.TENANT_ID,
};
//Aserto authorizer middleware function
const checkAuthz = jwtAuthz(authzOptions);
```

Set up the app middleware:

```js
app.use(morgan("dev"));
app.use(helmet());
app.use(cors({ origin: baseUrl }));
app.use(bodyParser.json());
```

In the next section, we'll define a protected route. Requests to this route will apply the `checkJwt` middleware to verify the validity of the JWT token, and the `checkAuthz` middleware that will use the JWT to check if the identity provided has authorization to access this path based on the policy. Finally, we'll start the server and have it listen on the configured port.

```js
// Set up middleware to return the display state map for this service
router.get("/api/protected", checkJwt, checkAuthz, (req, res) => {
  res.send({
    msg: "Very sensitive information presented here.",
  });
});

app.use(routerBasePath, router);
app.listen(port, () => console.log(`API Server listening on port ${port}`));
```

### Update `package.json`

In order to run both the application and the server concurrently, update the `scripts` portion of the `package.json` file:

```js
{
    ...
    scripts: {
        "dev": "concurrently \"next dev\" \"node service/api-server\"",
        "start": "concurrently \"next start\" \"node service/api-server\"",
        "start:api": "node service/api-server",
    }
}
```

### Update the `.env` file

Open the Aserto Console, navigate to the Policies tab and open the policy `hello-aserto-nextjs`. There you will find the information needed to set up your application with the hosted authorizer.

![policy-settings](/quickstart-next-and-node/policy-settings-next.png)

Add the following environment variables to your `.env` file:

```
POLICY_ID=<The "hello-aserto-nextjs" Policy ID`>
POLICY_ROOT=asertonextjs
AUTHORIZER_API_KEY=<Your Aserto Authorizer API key>
TENANT_ID=<Your Aserto Tenant ID>
AUTHORIZER_SERVICE_URL=https://authorizer.prod.aserto.com
```

## Add API route definition to the protected resource

Back in your application, under the `api` folder, create a new file called `protected.js` and add the following:

```js
import { getAccessToken, withApiAuthRequired } from "@auth0/nextjs-auth0";

export default withApiAuthRequired(async function protectedResource(req, res) {
  try {
    const apiOrigin = process.env.NETLIFY
      ? `${process.env.URL}/.netlify/functions/api-server`
      : "http://localhost:3001";
    const { accessToken } = await getAccessToken(req, res);
    const response = await fetch(`${apiOrigin}/api/protected`, {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    });
    let secret;

    const status = response.status;
    switch (status) {
      case 403:
        res
          .status(403)
          .json({ msg: "This resource is forbidden for this user" });
        break;
      case 500:
        res
          .status(500)
          .json({ msg: "There was an error authenticating this user" });
        break;
      case 200:
        try {
          secret = await response.json();
          res.status(200).json(secret);
        } catch (e) {
          res.status(500).json({ msg: "This was an error parsing the result" });
        }
        break;
    }
  } catch (error) {
    res.status(error.status || 500).json({ error: error.message });
  }
});
```

This API route will be protected by the Auth0 middleware which will check that the user has a valid session. If the `checkAuthz` doesn't allow the user to access, it will return a `403` status, and the appropriate error message would be shown to the user. If the user is `allowed` to access the resource, the status returned will be `200` and the payload passed back from the server will be shown to the user.

### Update `protectedPage.jsx`

To wire the page to the newly created API route, open `protectedPage.jsx` under `pages` and update it's contents:

```js
import React, { useState } from 'react';
import { withPageAuthRequired } from '@auth0/nextjs-auth0';
import { Button } from 'reactstrap';

export default withPageAuthRequired(function ProtectedPage(){
    const [state, setState] = useState({ response: undefined, error: undefined, displayState: undefined });

    const fetchApi = async () => {
        try {
          const response = await fetch('/api/protected');
          const { status } = response
          const data = await response.json();

          setState(previous => ({ ...previous, response: data, error: undefined, status }))
        } catch (error) {
          setState(previous => ({ ...previous, response: undefined, error }))
        }
    };

    const { response, status, error } = state
```

Next, we'll update the return value of the component. This section will include a button which will trigger the API, as well as an area to display the message returned from the server or alternatively an error message in case of a `403` or `500` status returned from the API route.

```js
    return  (
        <div className={styles.main}>
            <div className={styles.topMain}>
                <div className={styles.pageHeader}>
                    <h1>Protected Page</h1>
                </div>
                <div>
                    <Button className="mt-1"
                        onClick={e => {
                            e.preventDefault()
                            fetchApi()
                        }}
                        data-testid="external-action"
                        color='primary'
                    >
                      Fetch protected resource
                    </Button>
                </div>

            </div>
            <div className={styles.centerMain}>
                <div className="mt-3">
                    {status !== 500 && status !== 403 && response?.msg &&
                        <div>
                            <div className={styles.lottie}></div>
                            <div>
                                {response.msg}
                            </div>
                        </div>
                    }
                    {status === 403 &&
                        <div>
                            <div className={styles.sadLottie}></div>
                            <div>
                                Access is forbidden for this user.
                            </div>
                        </div>
                    }
                    {status === 500 &&
                        <div>
                            <div className={styles.sadLottie}></div>
                            <div>
                                An error has occurred.
                            </div>
                        </div>
                    }
                </div>
            </div>
            {error && (
                <div className="mt-3">
                    {error}
                </div>
            )}
        </div>
    )
})
```

### Review the application

Open your browser and navigate to `http://localhost:3000`. This time, we're going to test the application with a user which has the role of `project-manager` and with a user which has the role of `executive`. Our expectation is that only the `executive` will be able access the protected route we defined in our server.

First, log out of the application and log in with the following credentials:

User name: `nuriag@acmecorp.com`

Password: `V@rySecr#et321!`

:::note
You can view the roles users have in the [directory](https://console.aserto.com/ui/directory) before testing.
:::

Navigate to the "Protected Page", and click the button "Fetch protected resource"
This user has the role of `project-manager`, so the result of the operation will be "Access is forbidden for this user."

![access-forbidden](/quickstart-next-and-node/access-forbidden.png)

Next, log out of the application and log in with the following credentials, this time with a user with a role of `executive`:

User name: `jeffh@acmecorp.com`

Password: `V@rySecr#et321!`

This time, when you click on "Fetch protected resource", you should see the following:

![access-allowed](/quickstart-next-and-node/access-allowed.png)

## Add Conditional UI rendering

A common pattern for leveraging authorization in the UI is to conditionally render components based on the user’s access. We will expand our policy to include decisions that will be used by our application to conditionally render a message as well as disable/enable the button that triggers the call to fetch the protected resource.

### Update the policy

Let's first update our `data.json` file to include more roles and decisions, specifically the `enabled` and `visible` decisions. These decisions are going to be used by the `displayStateMap` utility which we'll review later.

```
{
  "roles": {
    "project-management": {
      "perms": {
        "asertonextjs.GET.api.protected": {
          "allowed": false,
          "visible": false,
          "enabled": false
        }
      }
    },
    "senior-management": {
      "perms": {
        "asertonextjs.GET.api.protected": {
          "allowed": false,
          "visible": false,
          "enabled": true
        }
      }
    },
    "executive": {
      "perms": {
        "asertonextjs.GET.api.protected": {
          "allowed": true,
          "visible": true,
          "enabled": true
        }
      }
    }
  }
}

```

Now, we'll update our policy file to reflect these changes: we'll add the default values for `enabled` and `visible` as well as their corresponding rules:

```
package asertonextjs.GET.api.protected

import input.user.attributes.roles as user_roles

default allowed = false

default visible = false

default enabled = false

allowed {
	some i
	data.roles[user_roles[i]].perms[path].allowed
}

visible {
	some i
	data.roles[user_roles[i]].perms[path].visible
}

enabled {
	some i
	data.roles[user_roles[i]].perms[path].enabled
}
```

### Updating the Policy Repository

Commit, tag and push the changes you made:

```
git commit -m "Added roles and enabled/visible decisions"
git tag v0.0.2
git push origin master
git push --tags
```

### Add Dependencies

To use the `displayStateMap` utility, add the `@aserto/aserto-spa-js` and `regenerator-runtime` dependencies:

```
yarn add @aserto/aserto-spa-js regenerator-runtime/runtime
```

### Create a new API route

Under `pages/api` create a new file called `displayState.js` and add the following:

```js
import { getAccessToken, withApiAuthRequired } from "@auth0/nextjs-auth0";
import "regenerator-runtime/runtime";

import createAsertoClient from "@aserto/aserto-spa-js";

export default withApiAuthRequired(async function shows(req, res) {
  try {
    const { method, path } = JSON.parse(req.body);
    const apiOrigin = process.env.NETLIFY
      ? `${process.env.URL}/.netlify/functions/api-server`
      : "http://localhost:3001";
    const { accessToken } = await getAccessToken(req, res);

    const aserto = await createAsertoClient({
      accessToken: accessToken, // valid access token
      serviceUrl: apiOrigin, // defaults to window.location.origin
      policyRoot: process.env.POLICY_ROOT, // policy root specified in the policy manifest
      endpoint: "/__displaystatemap", // access map endpoint, defaults to /__displaystatemap
    });

    try {
      res
        .status(200)
        .json(aserto.getDisplayState(method, path, process.env.POLICY_ROOT));
    } catch (e) {
      res
        .status(500)
        .json({ msg: "Error while trying to resolve display state map" });
    }
  } catch (error) {
    res.status(error.status || 500).json({ error: error.message });
  }
});
```

This section initializes the Aserto client, and uses the client to trigger the `getDisplayState` for the corresponding `method` and `path` in the policy.

### Update the application

Update the state object to include `displayState`:

```js
const [state, setState] = useState({
  response: undefined,
  error: undefined,
  displayState: undefined,
});
```

Add an effect to fetch the displayState for the protected route `/api/protected` and method `GET`:

```js
useEffect(() => {
  const getDisplayState = async () => {
    try {
      const response = await fetch("/api/displayState", {
        method: "POST",
        body: JSON.stringify({ path: "/api/protected", method: "GET" }),
      });
      const data = await response.json();
      setState((previous) => ({
        ...previous,
        displayState: data,
        error: undefined,
      }));
    } catch (error) {
      setState((previous) => ({ ...previous, displayState: undefined, error }));
    }
  };

  getDisplayState();
}, []);
```

Next, we'll update the button so that it is disabled based on the result of the call to `/api/displayState`.

```js
<Button
  className="mt-1"
  onClick={(e) => {
    e.preventDefault();
    fetchApi();
  }}
  data-testid="external-action"
  color={state.displayState?.enabled ? "primary" : "secondary"}
  disabled={!state.displayState?.enabled}
>
  Fetch protected resource
</Button>
```

We'll also add a message that based on our policy, will only be `visible` to people with the role of `executive`:

```js
<p>
  {state.displayState?.visible && (
    <h3>This message is visible only to Executives</h3>
  )}
</p>
```

### Review the application

Now that we've added conditional behavior to our application, let's see it in action: first, log in as our `executive` user:

User name: `jeffh@acmecorp.com`
Password: `V@rySecr#et321!`

On the protected page, you'll be able to see the message intended for executives only, and clicking the "Fetch protected resource" button will complete successfully, showing the sensitive information.

![access-allowed-with-message](/quickstart-next-and-node/access-allowed-with-message.png)

The message is shown because the decision `visible` for the resource `/api/protected` for the role `executive` is `true`. The button is enabled because the `enabled` decision is also `true` for this role. Lastly, this user can retrieve the sensitive information because the `allowed` decision for the role and resource is also `true`.

Next, we'll log in as a `product-manager` again.

User name: `nuriag@acmecorp.com`

Password: `V@rySecr#et321!`

This time, the decision `enabled` for the resource `/api/protected` for the role `product-manager` is `false`, and so the button will be disabled. Similarly, the `visible` decision for the role and resource is `false` and so the message for executives will not be shown.

![access-forbidden-disabled](/quickstart-next-and-node/access-forbidden-disabled.png)

We can now test a user with the role `senior-management`. Use the following credentials:

User name: `karenb@acmecorp.com`

Password: `V@rySecr#et321!`

![access-forbidden-enabled](/quickstart-next-and-node/access-forbidden-enabled.png)

For this user, the button is going to be `enabled`, but the decision `allowed` is false - and so even though they'll be able to click the button, they will not be able to see the sensitive information. Similar to the `product-manager`, the message for executives will not be shown given that the `visible` decision is `false` for this role and resource.

## Add Netlify Support

In order to be able to deploy the server to Netlify as a function, we'll add the dependency `serverless-http`:

```
yarn add serverless-http
```

Then, we'll make the following change to the file `service/api-server.js`:

Replace the lines:

```js
const baseUrl = process.env.AUTH0_BASE_URL;
const routerBasePath = "/";
```

with:

```js
const isNetlify = process.env.NETLIFY;
const baseUrl = isNetlify ? process.env.URL : process.env.AUTH0_BASE_URL;
const routerBasePath = isNetlify ? "/.netlify/functions/api-server" : "/";
```

And replace the last line:

```js
app.listen(port, () => console.log(`API Server listening on port ${port}`));
```

with:

```js
if (isNetlify) {
  const serverless = require("serverless-http");
  exports.handler = serverless(app);
} else {
  const server = app.listen(port, () =>
    console.log(`API Server listening on port ${port}`)
  );
  process.on("SIGINT", () => server.close());
}
```

Next, we'll make the following changes to the application: in both `pages/api/protect.js` and `pages/api/displayState`, replace the line:

```js
const apiOrigin = "http://localhost:3001";
```

with:

```js
const apiOrigin = process.env.NETLIFY
  ? `${process.env.URL}/.netlify/functions/api-server`
  : "http://localhost:3001";
```

This will ensure that when in the Netlify environment, the app will use the generated URL for the app and point the server request to the Netlify function endpoint.

After you make these changes, be sure to commit and push them to a public Github/GitLab/Bitbucket repository.

### Deploy to Netlify

Log in to netlify, and click on New site from Git. Connect to your Git provider, and pick the repository you pushed the application to. Since we'll have to to edit the environment variables, you can cancel the deployment immediately. In the Environment tab under "Environment variables", add all the variables that appear in your `.env` file and their corresponding values.

:::caution note
Additionally, you'll have to define an enviornment variable named `AUTH0_BASE_URL` and set its value to be the same as the base URL of your deployed Netlify app.
:::

When you're done, re-trigger the deployment and then inspect the application.

## Summary

In this post we learned how to set up a Next.js application with an Express.js backend, using Auth0 as an identity provider. We saw how to write an authorization policy for the Aserto Authorizer, how to modify and deploy it and finally how to use is in the context of the Express.js server as well as the Next.js application with the `displayState` utility.
