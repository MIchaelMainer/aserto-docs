---
sidebar_label: React and Node - Chapter 1
---

# React.js and Node.js (Express.js) Quick Start

## Overview

Aserto is a could-native authorization platform that allows you to avoid having to build your own access control solution and instead frees you up to focus on your core user experience. In this tutorial you will learn how to integrate the Aserto SDK in the context of an Express.js API that will interact with a React application.

Before we get started, let’s discuss two of Aserto's major components: the Authorizer and the Control Plane.

The Authorizer is where authorization decisions get made. It is an open source authorization engine which uses Open Policy Agent (OPA) to compute a decision based on policy, user context and resource data. In this tutorial we’re going to use the hosted version of this authorizer.

The Control Plane manages the lifecycle of policies, user context, and resource data that are used by the authorizer. The control plane makes it easy to manage these artifacts centrally, and takes care of the details of synchronizing them to the Authorizer instance(s) deployed at the edge.

At the core of Aserto’s authorization model is an authorization policy, which we refer to simply as a Policy. Policies are authored in a textual language called Rego, defined as part of the Open Policy Agent (OPA) project in the Cloud Native Computing Foundation. Policies are treated just like application code or infrastructure-as-code - they are stored and versioned in a git repository. We’re going to define and see the policy in action later in this tutorial.

When you’ve completed this tutorial you'll have learned how to:

1. Create a React application with authentication using `oidc-react`
2. Set up a simple Express.js application with authentication middleware and define a protected route
3. Create and modify a very simple authorization policy
4. Integrate the Aserto Authorization Express.js SDK to enable fine grained access control
5. Conditionally render UI elements based on user access

## Prerequisites

To get started, you’re going to need:

1. Node.JS installed on your machine
2. Aserto account and credentials
3. Your favorite code editor

## Add Acmecorp Connection

Log in to your Aserto account. To add the Acmecorp identity provider, go to the Connections tab, and click “Add connection”.

![add-connection-button](/quickstart-react-and-node/add-connection-button.png)

From the dropdown, select “acmecorp”:

![add-acmecorp-connection](/quickstart-react-and-node/add-acmecorp-connection.png)

Name the provider (you can choose whatever name you want) and give it a description. Then, click “Add connection” to complete the process.

# Review your Users

Click on the “Users” panel. The users you’ll see have been imported from the identity provider Acemcrop into your directory. Let’s review a couple of users: Search the directory for Euan Garden and click on his user card.

![euan-garden-card](/quickstart-react-and-node/euan-garden-card.png)

You’ll see the following JSON object (shortened here for brevity):

```
{
  "id": "cirkzmrhzgmzos03mzm1ltqwngqtywy2ni1jnzdjzjezyte1zjgsbwxvy2fs",
  "enabled": true,
  "display_name": "Euan Garden",
  "email": "euang@acmecorp.com",
  ...
  "identities": {
    ...
  },
  "attributes": {
    "properties": {
      "department": "Sales Engagement Management",
      "manager": "2bfaa552-d9a5-41e9-a6c3-5be62b4433c8",
      "phone": "+1-804-555-3383",
      "title": "Salesperson"
    },
    "roles": [
      "acmecorp",
      "sales-engagement-management",
      "user",
      "viewer"
    ],
    ...
  },
  ...
}
```

Users in this identity provider have properties and roles associated with them. In this case, among other roles, Euan has the role of a “viewer”. If you search the Aserto directory for the user Kris Johnson and inspect her associated JSON object, you’ll see she has the role of “admin”. Later in this tutorial we will leverage these roles to allow the authorizer to make a decision as to which user will have access to a piece of sensitive information. Before we do that, we have to set up our React application as well as the Express.js application.

## React Application setup

We’re going to build a very bare bones application for this tutorial. We’ll start by creating an application using the create-react-app generator: In your terminal, execute the following command:

```
npx create-react-app aserto-react-demo
```

You can now cd aserto-react-demo and start the app by running:

```
yarn start
```

The familiar React logo should appear, indicating that the app is ready to go.

## Adding OIDC dependencies

Now that we have a running React application, we'll continue by installing and then importing the required dependency - `oidc-react`

In your terminal, execute the following command:

```
yarn install oidc-react
```

The following environment variables are used to point your application to Aserto’s demo IDP, so that you don’t have to set one yourself. Create a file called `.env` and add the following:

```
REACT_APP_OIDC_DOMAIN=acmecorp.demo.aserto.com
REACT_APP_OIDC_CLIENT_ID=acmecorp-app
REACT_APP_OIDC_AUDIENCE=acmecorp-app
REACT_APP_API_ORIGIN=http://localhost:8080
```

:::caution note
Make sure the `.env` file is added to the `.gitignore` file so that it is not checked in.
:::

Open the file `index.js` and add the dependency:

```javascript
import { AuthProvider } from "oidc-react";
```

Add the following configuration object:

```javascript
const configuration = {
  authority: `https://${process.env.REACT_APP_OIDC_DOMAIN}/dex`,
  clientId: process.env.REACT_APP_OIDC_CLIENT_ID,
  autoSignIn: true,
  responseType: "id_token",
  scope: "openid profile email",
  redirectUri: window.location.origin,
  audience: process.env.REACT_APP_OIDC_AUDIENCE,
  onSignIn: () => {
    window.location.replace(window.location.origin);
  },
};
```

Next, we'll wrap the top level React Application component with the AuthProvider, and pass it the required configuration we created.

```javascript
ReactDOM.render(
  <React.StrictMode>
    <AuthProvider {...configuration}>
      <App />
    </AuthProvider>
  </React.StrictMode>,
  document.getElementById("root")
);
```

Next, we’ll build the app itself. Open the `App.js` file, and replace it’s contents with:

```javascript
import "./App.css";
import React from "react";
import { useAuth } from "oidc-react";

function App() {
  const auth = useAuth();
  const isAuthenticated = auth.userData?.id_token ? true : false;

  return (
    <div className="container">
      <div className="header">
        <div className="logo-container">
          <div className="logo"></div>
          <div className="brand-name"></div>
        </div>
      </div>

      <div className="user-controls">
        {isAuthenticated && (
          <>
            <div className="user-info">{auth.userData?.profile?.email}</div>
            <div className="seperator"></div>
            <div className="auth-button">
              <div onClick={() => auth.signOut("/")}>Log Out</div>
            </div>
          </>
        )}
        {!isAuthenticated && (
          <div className="auth-button">
            <div onClick={() => auth.signIn("/")}>Login</div>
          </div>
        )}
      </div>

      <div className="main">
        {isAuthenticated && (
          <>
            <div className="top-main">
              <div className="welcome-message">
                Welcome {auth.userData?.profile?.email}!
              </div>
            </div>
          </>
        )}
      </div>
    </div>
  );
}

export default App;
```

## Test the application

Let's test our application by logging in. If it's not already running, start your application by executing:

```
yarn start
```

To log in, using the following credentials:

User: euang@acmecorp.com
Password: V@erySecre#t123!

![acmecorp-login](/quickstart-react-and-node/acmecorp-login.png)

If everything works as expected, the following should be displayed.

![welcome-euan-message](/quickstart-react-and-node/welcome-euan-message.png)

Great! Our application authenticates with the Acmecorp IDP, and so we have our user's identity in hand. We now turn to creating the Express.js service which will host our sensitive resource and will communicate with the Aserto hosted authorizer to determine whether or not a logged in user has the permissions to access the said resource based on the user's identity.

# Service Setup

First, create a new folder called service under the React application folder and run:

```
yarn init -y
yarn install express express-jwt jwks-rsa cors express-jwt-aserto dotenv npm-run-all
```

To the `.env` file we created previously, add the following:

```
JWKS_URI=https://acmecorp.demo.aserto.com/dex/keys
AUTH_ISSUER=https://acmecorp.demo.aserto.com/dex
AUTH_AUDIENCE=acmecorp-app
```

In the `service` folder, Create a file called index.js - that will be our server. To this file, add the following dependencies:

```javascript
const express = require("express");
const app = express();
const jwt = require("express-jwt");
const jwksRsa = require("jwks-rsa");
const cors = require("cors");
const { displayStateMap, jwtAuthz } = require("express-jwt-aserto");
require("dotenv").config();
```

In the next section we define the middleware function which will call our identity provider to verify the validity of the JWT (and also enable CORS): Express.js will pass the call to the `checkJwt` middleware which will determine whether the JWT sent to it is valid or not. If it is not valid, Express.js will return a 403 (Forbidden) response.

```javascript
//Paste after the dependencies

const checkJwt = jwt({
  // Dynamically provide a signing key based on the kid in the header and the signing keys provided by the JWKS endpoint
  secret: jwksRsa.expressJwtSecret({
    cache: true,
    rateLimit: true,
    jwksRequestsPerMinute: 5,
    jwksUri: process.env.AUTH0_JWKS_URI,
  }),

  // Validate the audience and the issuer
  audience: process.env.AUDIENCE,
  issuer: process.env.ISSUER,
  algorithms: ["RS256"],
});
```

Lastly, we set up a protected route which will use the `checkJwt` middleware:

```javascript
// Enable CORS
app.use(cors());

// Next section of code to be pasted below
// Next, we'll create the protected endpoint:
// Protected API endpoint
app.get("/api/protected", checkJwt, function (req, res) {
  //send the response
  res.json({ secret: "Very sensitive information presented here" });
});

// Launch the API Server at localhost:8080
app.listen(8080);
```

## Update the application

To test this endpoint we're going to have to make sure the React app actually sends the authentication token to the server and requests the protected resources. To do that, we'll have to make some changes to the App.js file in our React app.

```javascript
function App() {
   const auth = useAuth();
   const [message, setMessage] = useState(false)
   const isAuthenticated = auth.userData?.id_token ? true : false

   const accessSensitiveInformation = useCallback(async () => {
        try {
            if (!auth.isLoading) {
                const accessToken = auth.userData?.id_token
                const sensitiveInformationURL = `${process.env.REACT_APP_API_ORIGIN}/api/protected`;
                const sensitiveDataResponse = await fetch(sensitiveInformationURL, {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                });

                try {
                    const res = await sensitiveDataResponse.json();
                    setMessage(res.secret)
                } catch (e) {
                    //In case no access is given, the response will return 403 and not return a JSON response
                    setMessage(sensitiveDataResponse.status)
                }
            }

        } catch (e) {
            console.log(e.message);
        }

    }, [auth.isLoading, auth.userData?.id_token])

   ...

```

In this portion of the code we create a callback (which will be triggered by a button). The callback will first get our JWT token from the identity provider, using the `auth` object that is obtained from the `useAuth` hook. Then we perform the call to our service sending the authorization token as part of our request's headers (fetch). Finally, we parse the JSON response from the server and set the state of the message variable: if the service returns a `403 Forbidden` error, and the message “No access to sensitive information” will be shown. If no error is returned from the service, the user has access to the protected resource and the message will be shown.

Next we’ll update the `main` section of the app (in the `div` with the className `main`) to include the button that will trigger `accessSensitiveInformation` and an area to show the message.

```javascript
<div className="main">
  {isAuthenticated && (
    <>
      <div className="top-main">
        <div className="welcome-message">
          Welcome {auth.userData?.profile?.email}!
        </div>
        <div>
          {!message && (
            <button
              className="primary-button"
              onClick={() => accessSensitiveInformation()}
            >
              Get Sensitive Resource
            </button>
          )}
          <div className="message-container">
            {message && message !== 403 && (
              <>
                <div className="lottie"></div>
                <div className="message">{message}</div>
              </>
            )}
            {message && message === 403 && (
              <>
                <div className="sad-lottie"></div>
                <div className="message">
                  No access to sensitive information
                </div>
              </>
            )}
          </div>
        </div>
      </div>
    </>
  )}
</div>
```

## Test the application

To run both your application and the server in parallel, update the `package.json` in the root folder, and add the following to the `scripts` section:

```
"scripts": {
   ...
   "start:server": "node service/index.js",
   "start:all": "npm-run-all --parallel start start:server"
 },
```

To start both the application and the server, you can now run:

```
yarn start:all
```

Let's test our application by first logging out, then logging in again with the user `krisj@acmecrop.com` and the password `V@erySecre#t123!`.

If everything works as expected, we should see the email for the account we logged in with, as well as the label "Very sensitive information presented here".

![krisj-login](/quickstart-react-and-node/krisj-login.png)

We can further test this by intentionally sending a malformed header and making sure the sensitive information isn't shown. One way to do this is to append so rouge characters to the access token like so:

```
...
const sensitiveDataResponse = await fetch(sensitiveInformationURL, {
   headers: {
       Authorization: `Bearer ${accessToken}SOME_ROGUE_CHARECTERS`,
   },
});
```

In this case we'd expect the sensitive information to not be shown.

## Creating a simple Role Based Access Control Authorization Model

Until now, we dealt only with authentication of users in our application. Now, let’s discuss how to set up the _authorization_ model which will enforce some limitation on user access to our protected resource.

We want to limit access to specific protected resources in our application to users who have particular roles. In this case, if we logged in with `euang@acmecorp.com` - who has the “viewer” role and not the “admin” role, we’d expect him not to have access to our protected resource. If you log in as `euang@acmecorp.com` you’ll see the following:

![euan-gets-sensitive-information](/quickstart-react-and-node/euan-gets-sensitive-information.png)

That's not the behavior we’re looking for - but since we didn't add any way to authorize users based on their role - this unprivileged user still has access to the protected route. Let's fix that by first creating a simple Aserto policy to allow access only to users with the “admin” role.

## Create an Aserto Policy

Initially, the policy we’ll create for this tutorial will only allow a user with the role of `admin` to view sensitive information, while users without the `admin` role will not be able to access that information.

In [console.aserto.com](https://console.aserto.com), go to the `Policies` tab and click "Add Policy"

![add-policy](/quickstart-react-and-node/add-policy.png)

If you haven't already added a source code connection, select "Add a new source code connection". You can choose either adding a Github connection using an Oauth2 flow, or add a Github connection using a Github PAT.

![add-scc](/quickstart-react-and-node/add-scc.png)

Once you've added the connection, select the organization you'd like to use for the repository, and select "New (using template)".

Then, from the template dropdown, select "aserto-dev/policy-template". Name repo policy "hello-aserto-react", and click "Create repo".

![add-policy-to-repo](/quickstart-react-and-node/add-policy-to-repo.png)

Aserto will generate a new repository in your Github account the will include the necessary policy files. Head to Github to retrieve the URL for the repository that was just created, and clone it.

```
git clone git@github.com:<YOUR ORGANIZATION>/hello-aserto-react.git
```

Now that we have a local copy of the policy, let’s start modifying it:

We'll start by updating the `.manifest` file under `src`, which currently will only point to the root of our policy. We'll change it from

```
{
    "roots": ["policies"]
}
```

To

```
{
    "roots": ["asertodemo"]
}
```

Rename the file `hello.rego` to `protected.rego`. We'll open the file and change the package name to match the path of our Express API endpoint. The basic structure of the package name is:

```
[policy-root].[VERB].[path]
```

Where the path is separated by dots instead of slashes. And so in our case, the Express.js path

```
app.get('/api/protected'...
```

Is referenced in the package as:

```
package asertodemo.GET.api.protected
```

We're also going to define the policy such that the only `allowed` user is one with an `admin` role. Aserto attaches this `user` object to the `input` object. Below is the finished policy:

```
package asertodemo.GET.api.protected

default allowed = false

allowed {
	some index
	input.user.attributes.roles[index] == "admin"
}
```

By default, the `allowed` decision is going to be `false` - this follows the principle of a “closed” system where access is disallowed unless specific conditions are satisfied.

At runtime, the application will send the JWT associated with the logged in user. The Express.js service will relay the JWT along with the request path as the identity and resource contexts respectively to the authorizer. The `some index` and `...roles[index]` expressions indicate the authorizer will iterate over all the elements in the `roles` array under the `attributes` property in the user object. The authorizer will check if the iterated role is equal to the string `admin`. If it is, the `allowed` decision will be `true`.

## Updating the Policy Repository

Now that we’ve modified our policy bundle, we’ll publish our changes: Aserto applies a GitOps flow to any changes made to the repository we set up. That means that we can simply tag and push the changes we’ve made to the policy and the updated policy will be built and published to the authorizer.

Commit, tag and push the changes you made:

```
git commit -m "updated policy"
git tag v0.0.1
git push origin master
git push --tags
```

## Update the Express service to use the Aserto middleware

We now need to configure and apply the Aserto middleware. In order to avoid saving any secret credentials in our source code, we'll add the following credentials to our `.env` file. To find these credentials, click on your policy in the Policies tab. Then choose the "Policy settings" tab.

Copy the following values to the `.env` file:

```
POLICY_ROOT=asertodemo
POLICY_ID={Your Policy ID}
AUTHORIZER_API_KEY={Your Authorizer API Key}
TENANT_ID={Your tenant ID}
```

Continue by creating the configuration object for the Aserto middleware:

```javascript
const authzOptions = {
  authorizerServiceUrl: process.env.AUTHORIZER_SERVICE_URL,
  policyId: process.env.POLICY_ID,
  policyRoot: process.env.POLICY_ROOT,
  authorizerApiKey: process.env.AUTHORIZER_API_KEY,
  tenantId: process.env.TENANT_ID,
};
```

We'll define a function for the Aserto middleware, and pass it the configuration object.

```
//Aserto authorizer middleware function
const checkAuthz = jwtAuthz(authzOptions);
```

Lastly, add the `checkAuthz` middleware to our protected path.

```
//Protected API endpoint
app.get("/api/protected", checkJwt, checkAuthz, function (req, res) {
  //send the response
  res.json({ secret: "Very sensitive information presented here" });
});
```

The `checkAuthz` middleware is going to pass the request context - which consists of the policy reference (based on the request path), the identity context (based on the JWT token passed) and resource context (based on the request parameters) - to the authorizer, which given the policy will determine what the `allowed` decision would be.

## Test the Application

Before testing the application, stop both the application and the server by hitting `ctrl+c` and run`yarn start:all` again.

When we log in with the user `krisj@acmecorp.com` who has the role of an `admin` we will still be able to see the "Very sensitive information presented here". If we log out and log in again as `euang@acmecorp.com` we will see the message “No access to sensitive information” - since this user doesn’t have the role of `admin`, the path `/api/protected` will be disallowed.

## Expand the policy

So far, we have defined rules that support a single role - `admin`. We’ll now expand our policy to cover more roles by adding a data file to our policy bundle. In addition to policy Rego files, we can add JSON files that the policy can refer to in runtime.
Create a new file and name it `data.json` and add the following contents:

```javascript
{
  "roles": {
    "viewer": {
      "description": "A viewer with no access to sensitive asset",
      "perms": {
        "asertodemo.GET.api.protected": {
          "allowed": false
        }
      }
    },
    "editor": {
      "description": "A editor with access to sensitive asset",
      "perms": {
        "asertodemo.GET.api.protected": {
          "allowed": true
        }
      }
    },
    "admin": {
      "description": "An admin user with access to sensitive asset",
      "perms": {
        "asertodemo.GET.api.protected": {
          "allowed": true
        }
      }
    }
  }
}
```

In order to reference the data file in our policy, we’ll update our policy file:

```
package asertodemo.GET.api.protected

import input.policy.path
import input.user.attributes.roles as user_roles


default allow = false

allowed {
	some index
	data.roles[user_roles[index]].perms[path].allowed
}
```

We have two import statements: one for referencing the policy path (`asertodemo.GET.api.protected`) and one to reference the user roles that are a part of the user object.
The Rego rule declared here will:

1. Iterate over all the user roles (using the `some index` expression and the `user_roles[index]` expression)
2. For each of them, it’ll refer back to the `data.json` file and attempt to find the corresponding entry (e.g., `viewer`, `editor`, `admin` under `roles`
3. Once found, it’ll attempt to resolve the path `perms.asertodemo.GET.api.protected.allowed` for that “role” and return the value.
   So, for example, the resolution for the “viewer” role would be `data.json` -> `roles` -> `viewer` -> `perms` -> `asertodemo.GET.api.protected` -> `allowed` -> `false`.

## Update the `.manifest` file

To allow for the use of `roles` in the `data.json` file, update your `.manifest` file:

```
{
    "roots": ["asertodemo", "role"]
}
```

Commit, tag and push the changes you made:

```
git commit -m "added data.json file"
git tag v0.0.2
git push origin master
git push --tags
```

In the Aserto console, open the Policy Browser and check that the changes you’ve made are reflected.

:::caution note
TODO: Screenshot
:::

## Test the application

With the new changes to the policy, we can now test a user with the role of `editor` to make sure they can indeed access the protected resource. Log in with the user `dianet@acmecorp.com` (who has the `editor` role) using the password `V@erySecre#t123!`.

![diant-gets-sensitive-infromation](/quickstart-react-and-node/diant-gets-sensitive-infromation.png)

Success! As expected, this user can access the protected resource.

# Summary

In this tutorial, we created a simple React application and a simple Express.js application, using OICD as an identity provider. We then set up an Aserto Policy to limit user access to a protected resource using the identity context passed from the React Application. Finally, we saw how to make changes to the policy without requiring any changes to the application code.

In the next tutorial, we’ll learn how to conditionally render UI components based on policy decisions.
